"""
LLVM IR generator for C code.
This module converts the semantic analysis results to LLVM IR using llvmlite.
"""

from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass
from enum import Enum
import llvmlite.ir as ir
import llvmlite.binding as llvm
from pathlib import Path
import sys
from lark import Tree, Token
from ..analysis.semantic import SemanticAnalyzer, Type, TypeKind, Symbol, SymbolTable, analyze_c_code
from ..analysis.parser import create_parser, parse_c_code, read_c_file
import logging

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Initialize LLVM
llvm.initialize()
llvm.initialize_native_target()
llvm.initialize_native_asmprinter()

@dataclass
class IRContext:
    """Context for IR generation, holding module and builder state"""
    module: ir.Module
    builder: ir.IRBuilder
    current_function: Optional[ir.Function] = None
    symbol_table: Dict[str, ir.Value] = None
    scope_stack: List[Dict[str, ir.Value]] = None

    def __post_init__(self):
        if self.symbol_table is None:
            self.symbol_table = {}
        if self.scope_stack is None:
            self.scope_stack = [self.symbol_table]

    def enter_scope(self):
        """Enter a new scope for variable declarations"""
        self.scope_stack.append({})

    def exit_scope(self):
        """Exit current scope"""
        if len(self.scope_stack) > 1:
            self.scope_stack.pop()

    def add_symbol(self, name: str, value: ir.Value):
        """Add a symbol to the current scope"""
        logger.debug(f"Adding symbol {name} to scope with value: {repr(value)}")
        self.scope_stack[-1][name] = value

    def lookup(self, name: str) -> Optional[ir.Value]:
        """Look up a symbol in current and outer scopes"""
        for scope in reversed(self.scope_stack):
            if name in scope:
                logger.debug(f"Found symbol {name} in scope: {repr(scope[name])}")
                return scope[name]
        logger.debug(f"Symbol {name} not found in any scope")
        return None

class IRGenerator:
    """Generates LLVM IR from semantic analysis results"""

    def __init__(self, semantic_analyzer: SemanticAnalyzer):
        logger.debug("Initializing IRGenerator")
        self.semantic = semantic_analyzer
        self.module = ir.Module(name="c_module")
        # Initialize with a temporary function that we'll never use
        # but is needed for the IRBuilder
        logger.debug("Creating temporary function")
        self.temp_func = ir.Function(self.module, ir.FunctionType(ir.VoidType(), []), "temp")
        self.temp_block = self.temp_func.append_basic_block("temp_entry")
        self.context = IRContext(
            module=self.module,
            builder=ir.IRBuilder(self.temp_block)
        )
        self.type_map = {
            TypeKind.INT: ir.IntType(32),
            TypeKind.FLOAT: ir.FloatType(),
            TypeKind.CHAR: ir.IntType(8),
            TypeKind.VOID: ir.VoidType(),
            TypeKind.DOUBLE: ir.DoubleType()
        }
        self._declare_runtime_functions()
        self.has_main = False  # Track if we have a main function
        logger.debug("IRGenerator initialization complete")

    def _declare_runtime_functions(self):
        """Declare runtime functions like printf and scanf"""
        # printf declaration
        printf_type = ir.FunctionType(
            ir.IntType(32),  # return type
            [ir.PointerType(ir.IntType(8))],  # format string
            var_arg=True  # variable arguments
        )
        self.printf = ir.Function(self.module, printf_type, "printf")

        # scanf declaration
        scanf_type = ir.FunctionType(
            ir.IntType(32),  # return type
            [ir.PointerType(ir.IntType(8))],  # format string
            var_arg=True  # variable arguments
        )
        self.scanf = ir.Function(self.module, scanf_type, "scanf")

    def _get_llvm_type(self, type_info: Type) -> ir.Type:
        """Convert semantic type to LLVM type"""
        # For basic types, return the base type directly
        if type_info.kind == TypeKind.INT:
            return ir.IntType(32)  # Return i32 directly
        elif type_info.kind == TypeKind.FLOAT:
            return ir.FloatType()  # Return float directly
        elif type_info.kind == TypeKind.CHAR:
            return ir.IntType(8)  # Return i8 directly
        elif type_info.kind == TypeKind.VOID:
            return ir.VoidType()
        elif type_info.kind == TypeKind.DOUBLE:
            return ir.DoubleType()  # Return double directly
        elif type_info.kind == TypeKind.POINTER:
            # For pointer types, we want to return the base type directly
            # since the alloca instruction will create the pointer for us
            return self._get_llvm_type(type_info.base_type)
        elif type_info.kind == TypeKind.ARRAY:
            base_type = self._get_llvm_type(type_info.base_type)
            return ir.ArrayType(base_type, type_info.array_size)
        elif type_info.kind == TypeKind.FUNCTION:
            param_types = [self._get_llvm_type(t) for t in type_info.param_types]
            return_type = self._get_llvm_type(type_info.return_type)
            return ir.FunctionType(return_type, param_types)
        # Default to i32 if we can't determine the type
        return ir.IntType(32)  # Return i32 directly

    def _create_function(self, name: str, type_info: Type) -> ir.Function:
        """Create a function with the given type information"""
        param_types = [self._get_llvm_type(t) for t in type_info.param_types]
        return_type = self._get_llvm_type(type_info.return_type)
        func_type = ir.FunctionType(return_type, param_types)
        return ir.Function(self.module, func_type, name)

    def _function_exists(self, name: str) -> bool:
        """Check if a function exists in the module"""
        return any(f.name == name for f in self.module.functions)

    def _is_terminator(self, instr) -> bool:
        """Check if an instruction is a terminator"""
        logger.debug(f"Checking if instruction is terminator: {instr}")
        try:
            # First check if it's a string representation
            if isinstance(instr, str):
                logger.debug("Instruction is a string, checking opname")
                return instr.startswith(('ret', 'br'))
            
            # Then check if it's an actual instruction
            if hasattr(instr, 'opname'):
                logger.debug(f"Instruction has opname: {instr.opname}")
                return instr.opname in ('ret', 'br')
            
            # Finally check if it's the last instruction in its block
            if hasattr(instr, 'parent') and hasattr(instr.parent, 'instructions'):
                is_last = instr == instr.parent.instructions[-1]
                logger.debug(f"Instruction is last in block: {is_last}")
                return is_last
            
            logger.debug("Could not determine if instruction is terminator")
            return False
        except Exception as e:
            logger.error(f"Error checking terminator: {e}")
            logger.error(f"Instruction type: {type(instr)}")
            logger.error(f"Instruction repr: {repr(instr)}")
            return False

    def _get_instruction_type(self, instr) -> str:
        """Get the type of instruction"""
        logger.debug(f"Getting instruction type for: {instr}")
        try:
            # First check if it's a string
            if isinstance(instr, str):
                logger.debug("Instruction is a string, parsing type")
                if instr.startswith('ret'):
                    return 'ret'
                elif instr.startswith('br'):
                    return 'br'
                # Add more instruction types as needed
                return 'unknown'
            
            # Then check if it has an opname
            if hasattr(instr, 'opname'):
                logger.debug(f"Using opname: {instr.opname}")
                return instr.opname
            
            # Finally try to get type from string representation
            instr_str = str(instr)
            logger.debug(f"Falling back to string representation: {instr_str}")
            
            # Log all possible attributes of the instruction
            logger.debug("Instruction attributes:")
            for attr in dir(instr):
                if not attr.startswith('__'):
                    try:
                        value = getattr(instr, attr)
                        logger.debug(f"  {attr}: {value}")
                    except Exception as e:
                        logger.debug(f"  {attr}: <error accessing: {e}>")
            
            if 'ret' in instr_str:
                return 'ret'
            elif 'br' in instr_str:
                return 'br'
            elif 'alloca' in instr_str:
                return 'alloca'
            elif 'store' in instr_str:
                return 'store'
            elif 'load' in instr_str:
                return 'load'
            elif 'add' in instr_str:
                return 'add'
            elif 'sub' in instr_str:
                return 'sub'
            elif 'mul' in instr_str:
                return 'mul'
            elif 'sdiv' in instr_str:
                return 'sdiv'
            elif 'call' in instr_str:
                return 'call'
            logger.warning(f"Unknown instruction type: {instr_str}")
            return 'unknown'
        except Exception as e:
            logger.error(f"Error getting instruction type: {e}")
            logger.error(f"Instruction type: {type(instr)}")
            logger.error(f"Instruction repr: {repr(instr)}")
            return 'unknown'

    def _copy_terminator(self, instr, block_map, builder):
        """Copy a terminator instruction to the new block"""
        instr_type = self._get_instruction_type(instr)
        logger.debug(f"Copying terminator instruction of type: {instr_type}")
        logger.debug(f"Instruction: {repr(instr)}")
        
        # Log the actual block objects in the block map
        logger.debug("Block map contents (actual objects):")
        for old_block, new_block in block_map.items():
            logger.debug(f"  Old block: {repr(old_block)} (type: {type(old_block)})")
            logger.debug(f"  New block: {repr(new_block)} (type: {type(new_block)})")
        
        try:
            if instr_type == 'ret':
                # For ret, we need to check if it has operands
                if hasattr(instr, 'operands') and instr.operands:
                    logger.debug(f"Using operands for return: {[repr(op) for op in instr.operands]}")
                    # The first operand should be the return value
                    ret_val = instr.operands[0]
                    logger.debug(f"Return value type: {type(ret_val)}")
                    logger.debug(f"Return value repr: {repr(ret_val)}")
                    
                    # If it's already an ir.Value, use it directly
                    if isinstance(ret_val, ir.Value):
                        logger.debug(f"Using return value directly: {repr(ret_val)}")
                        # For constants, we need to be careful with the type
                        if isinstance(ret_val, ir.Constant):
                            # Get the actual type and value
                            const_type = ret_val.type
                            const_value = ret_val.constant
                            logger.debug(f"Constant type: {const_type}, value: {const_value}")
                            
                            # Create a new constant of the same type
                            if isinstance(const_type, ir.IntType):
                                # For integers, ensure we're using the correct width
                                width = const_type.width
                                logger.debug(f"Creating integer constant with width {width}")
                                new_const = ir.Constant(ir.IntType(width), int(const_value))
                                logger.debug(f"Created new constant: {repr(new_const)}")
                                # Use the constant directly without any string conversion
                                try:
                                    logger.debug("Attempting to create return instruction")
                                    builder.ret(new_const)
                                    logger.debug("Return instruction created successfully")
                                    return
                                except Exception as e:
                                    logger.error(f"Error creating return instruction: {e}")
                                    logger.error(f"Constant type: {type(new_const)}")
                                    logger.error(f"Constant repr: {repr(new_const)}")
                                    raise
                            elif isinstance(const_type, ir.FloatType):
                                logger.debug("Creating float constant")
                                new_const = ir.Constant(ir.FloatType(), float(const_value))
                                logger.debug(f"Created new constant: {repr(new_const)}")
                                try:
                                    builder.ret(new_const)
                                    return
                                except Exception as e:
                                    logger.error(f"Error creating return instruction: {e}")
                                    raise
                            elif isinstance(const_type, ir.DoubleType):
                                logger.debug("Creating double constant")
                                new_const = ir.Constant(ir.DoubleType(), float(const_value))
                                logger.debug(f"Created new constant: {repr(new_const)}")
                                try:
                                    builder.ret(new_const)
                                    return
                                except Exception as e:
                                    logger.error(f"Error creating return instruction: {e}")
                                    raise
                            else:
                                logger.error(f"Unsupported constant type: {const_type}")
                                builder.ret_void()
                                return
                        else:
                            # For non-constant values, use them directly
                            logger.debug(f"Using non-constant value of type {type(ret_val)}")
                            try:
                                builder.ret(ret_val)
                                return
                            except Exception as e:
                                logger.error(f"Error creating return instruction: {e}")
                                logger.error(f"Value type: {type(ret_val)}")
                                logger.error(f"Value repr: {repr(ret_val)}")
                                raise
                    elif isinstance(ret_val, str):
                        # Parse string like "i32 0"
                        logger.debug(f"Parsing return value string: {ret_val}")
                        type_str, value_str = ret_val.split()
                        if type_str == 'i32':
                            value = int(value_str)
                            ret_val = ir.Constant(ir.IntType(32), value)
                            logger.debug(f"Created return constant: {repr(ret_val)}")
                            try:
                                builder.ret(ret_val)
                                return
                            except Exception as e:
                                logger.error(f"Error creating return instruction: {e}")
                                raise
                        else:
                            logger.error(f"Unsupported return type: {type_str}")
                            builder.ret_void()
                            return
                    else:
                        # For other types, try to create a constant
                        try:
                            logger.debug(f"Attempting to convert return value: {ret_val}")
                            if isinstance(ret_val, (int, float)):
                                ret_val = ir.Constant(ir.IntType(32), int(ret_val))
                                logger.debug(f"Created return constant: {repr(ret_val)}")
                                try:
                                    builder.ret(ret_val)
                                    return
                                except Exception as e:
                                    logger.error(f"Error creating return instruction: {e}")
                                    raise
                            else:
                                logger.error(f"Unsupported return value type: {type(ret_val)}")
                                builder.ret_void()
                                return
                        except (ValueError, TypeError) as e:
                            logger.error(f"Could not convert return value: {ret_val}, error: {e}")
                            builder.ret_void()
                            return
                else:
                    logger.debug("No return value found, returning void")
                    try:
                        builder.ret_void()
                        return
                    except Exception as e:
                        logger.error(f"Error creating void return instruction: {e}")
                        raise
            elif instr_type == 'br':
                # For br, we need to check if it's conditional
                if hasattr(instr, 'operands'):
                    logger.debug(f"Branch operands: {[repr(op) for op in instr.operands]}")
                    for i, op in enumerate(instr.operands):
                        logger.debug(f"Operand {i} type: {type(op)}")
                        logger.debug(f"Operand {i} repr: {repr(op)}")
                        if isinstance(op, ir.Block):
                            logger.debug(f"Operand {i} is a block with name: {op.name}")
                        elif isinstance(op, str):
                            logger.debug(f"Operand {i} is a string: {op}")
                    
                    if len(instr.operands) > 1:
                        logger.debug("Copying conditional branch")
                        logger.debug(f"Condition: {repr(instr.operands[0])}")
                        logger.debug(f"True target: {repr(instr.operands[1])}")
                        logger.debug(f"False target: {repr(instr.operands[2])}")
                        
                        # Get the target blocks directly from the block map
                        true_target = block_map.get(instr.operands[1])
                        false_target = block_map.get(instr.operands[2])
                        
                        if true_target and false_target:
                            logger.debug(f"Using true target: {repr(true_target)}")
                            logger.debug(f"Using false target: {repr(false_target)}")
                            builder.cbranch(instr.operands[0], true_target, false_target)
                            return
                        else:
                            logger.error("Could not find branch targets in block map")
                            logger.error(f"True target found: {true_target is not None}")
                            logger.error(f"False target found: {false_target is not None}")
                            raise ValueError("Invalid branch targets")
                    else:
                        logger.debug("Copying unconditional branch")
                        logger.debug(f"Target: {repr(instr.operands[0])}")
                        
                        # Get the target block directly from the block map
                        target = block_map.get(instr.operands[0])
                        
                        if target:
                            logger.debug(f"Using target: {repr(target)}")
                            builder.branch(target)
                            return
                        else:
                            logger.error("Could not find branch target in block map")
                            logger.error(f"Target operand type: {type(instr.operands[0])}")
                            logger.error(f"Target operand repr: {repr(instr.operands[0])}")
                            raise ValueError("Invalid branch target")
        except Exception as e:
            logger.error(f"Error copying terminator instruction: {e}")
            logger.error(f"Instruction type: {type(instr)}")
            logger.error(f"Instruction repr: {repr(instr)}")
            logger.error(f"Available attributes: {dir(instr)}")
            if hasattr(instr, 'operands'):
                logger.error(f"Operands: {[repr(op) for op in instr.operands]}")
                for i, op in enumerate(instr.operands):
                    logger.error(f"Operand {i} type: {type(op)}")
                    logger.error(f"Operand {i} repr: {repr(op)}")
                    if hasattr(op, 'name'):
                        logger.error(f"Operand {i} name: {op.name}")
            raise

    def _copy_instruction(self, instr, builder):
        """Copy a non-terminator instruction using the builder"""
        instr_type = self._get_instruction_type(instr)
        logger.debug(f"Copying instruction of type: {instr_type}")
        
        try:
            if instr_type == 'alloca':
                # For alloca, we need the type
                logger.debug(f"Allocating memory of type: {instr.type}")
                builder.alloca(instr.type)
            elif instr_type == 'store':
                # For store, we need value and pointer
                if hasattr(instr, 'operands'):
                    logger.debug(f"Storing value: {instr.operands[0]} to: {instr.operands[1]}")
                    builder.store(instr.operands[0], instr.operands[1])
            elif instr_type == 'load':
                # For load, we need the pointer
                if hasattr(instr, 'operands'):
                    logger.debug(f"Loading from: {instr.operands[0]}")
                    builder.load(instr.operands[0])
            elif instr_type in ['add', 'sub', 'mul', 'sdiv']:
                # For arithmetic operations, we need both operands
                if hasattr(instr, 'operands'):
                    logger.debug(f"Performing {instr_type} on: {instr.operands[0]} and {instr.operands[1]}")
                    if instr_type == 'add':
                        builder.add(instr.operands[0], instr.operands[1])
                    elif instr_type == 'sub':
                        builder.sub(instr.operands[0], instr.operands[1])
                    elif instr_type == 'mul':
                        builder.mul(instr.operands[0], instr.operands[1])
                    elif instr_type == 'sdiv':
                        builder.sdiv(instr.operands[0], instr.operands[1])
            elif instr_type == 'call':
                # For call, we need the function and arguments
                if hasattr(instr, 'operands'):
                    callee = instr.operands[0]
                    args = instr.operands[1:]
                    logger.debug(f"Calling function: {callee} with args: {args}")
                    builder.call(callee, args)
        except Exception as e:
            logger.error(f"Error copying instruction: {e}")
            logger.error(f"Instruction type: {type(instr)}")
            logger.error(f"Instruction repr: {repr(instr)}")
            logger.error(f"Available attributes: {dir(instr)}")
            if hasattr(instr, 'operands'):
                logger.error(f"Operands: {instr.operands}")
            raise

    def generate(self) -> ir.Module:
        """Generate LLVM IR for the entire program"""
        logger.debug("Starting IR generation")
        try:
            # First handle all global declarations
            logger.debug("Processing global declarations")
            global_symbols = self.semantic.symbol_table.get_scope_symbols(0)
            logger.debug(f"Found {len(global_symbols)} global symbols")
            for symbol in global_symbols:
                logger.debug(f"Processing symbol: {symbol.name} (type: {symbol.type.kind})")
                if symbol.type.kind != TypeKind.FUNCTION:
                    self._generate_global_variable(symbol)
                elif symbol.name == "main":
                    logger.debug(f"Found main function in symbol table")
                    logger.debug(f"Main function body: {symbol.body is not None}")
                    if symbol.body:
                        logger.debug(f"Main function body type: {type(symbol.body)}")
                        logger.debug(f"Main function body data: {symbol.body.data}")
                    self.has_main = True

            # Then handle all function definitions
            logger.debug("Processing function definitions")
            for symbol in global_symbols:
                if symbol.type.kind == TypeKind.FUNCTION:
                    logger.debug(f"Processing function definition: {symbol.name}")
                    if symbol.name == "main":
                        logger.debug("Generating main function from semantic analyzer")
                        logger.debug(f"Main function body exists: {symbol.body is not None}")
                        if symbol.body:
                            logger.debug(f"Main function body type: {type(symbol.body)}")
                            logger.debug(f"Main function body data: {symbol.body.data}")
                            logger.debug(f"Main function body children: {[type(c) for c in symbol.body.children]}")
                        self._generate_function(symbol)
                    else:
                        # For other functions, just declare them
                        logger.debug(f"Declaring function: {symbol.name}")
                        self._create_function(symbol.name, symbol.type)

            # Create main function if it doesn't exist
            if not self.has_main:
                logger.debug("No main function found in symbol table, generating default main")
                self._generate_main_function()
            else:
                logger.debug("Main function was found and processed from symbol table")

            # Create a new module without the temporary function
            logger.debug("Creating new module")
            new_module = ir.Module(name="c_module")
            
            # Get all functions and globals from the module
            functions = [f for f in self.module.functions]
            # Filter globals to only include GlobalVariable objects
            globals = [g for g in self.module.globals 
                      if isinstance(g, ir.GlobalVariable) and g not in functions]
            
            logger.debug(f"Found {len(functions)} functions and {len(globals)} globals")
            logger.debug("Global variables:")
            for g in globals:
                logger.debug(f"  Global: {repr(g)} (type: {type(g)})")
            
            # Copy functions first
            for func in functions:
                if func.name != "temp":
                    logger.debug(f"Copying function: {func.name}")
                    try:
                        logger.debug(f"Creating new function with type: {func.function_type}")
                        new_func = ir.Function(new_module, func.function_type, func.name)
                        logger.debug(f"New function created: {repr(new_func)}")
                        
                        # Copy function attributes
                        for attr in func.attributes:
                            new_func.attributes.add(attr)
                        
                        # Create a mapping of old blocks to new blocks
                        block_map = {}
                        logger.debug(f"Processing blocks for function {func.name}")
                        for i, old_block in enumerate(func.basic_blocks):
                            # Use a simple numeric name for blocks
                            block_name = f"block_{i}"
                            logger.debug(f"Creating block {block_name} for function {func.name}")
                            logger.debug(f"Old block object: {repr(old_block)}")
                            new_block = new_func.append_basic_block(block_name)
                            logger.debug(f"New block object: {repr(new_block)}")
                            # Store the actual block objects in the mapping
                            block_map[old_block] = new_block
                            logger.debug(f"Added to block map: {id(old_block)} -> {id(new_block)}")
                            logger.debug(f"Block map now contains {len(block_map)} entries")
                            for k, v in block_map.items():
                                logger.debug(f"  Key type: {type(k)}, Value type: {type(v)}")
                                logger.debug(f"  Key: {repr(k)}")
                                logger.debug(f"  Value: {repr(v)}")
                        
                        # Copy instructions
                        logger.debug(f"Starting instruction copy for function {func.name}")
                        for old_block, new_block in block_map.items():
                            logger.debug(f"Copying instructions for block in {func.name}")
                            logger.debug(f"Old block object: {repr(old_block)}")
                            logger.debug(f"New block object: {repr(new_block)}")
                            logger.debug(f"Old block type: {type(old_block)}")
                            logger.debug(f"New block type: {type(new_block)}")
                            self.context.builder.position_at_end(new_block)
                            
                            # Log all instructions in the block
                            logger.debug(f"Instructions in old block:")
                            for instr in old_block.instructions:
                                logger.debug(f"  Instruction: {repr(instr)}")
                                logger.debug(f"  Instruction type: {type(instr)}")
                                if hasattr(instr, 'operands'):
                                    logger.debug(f"  Operands: {[repr(op) for op in instr.operands]}")
                                    for i, op in enumerate(instr.operands):
                                        logger.debug(f"    Operand {i} type: {type(op)}")
                                        logger.debug(f"    Operand {i} repr: {repr(op)}")
                                        if hasattr(op, 'name'):
                                            logger.debug(f"    Operand {i} name: {op.name}")
                            
                            for instr in old_block.instructions:
                                try:
                                    logger.debug(f"Processing instruction: {repr(instr)}")
                                    logger.debug(f"Instruction type: {type(instr)}")
                                    instr_type = self._get_instruction_type(instr)
                                    logger.debug(f"Instruction type: {instr_type}")
                                    
                                    if instr_type in ('ret', 'br'):
                                        logger.debug("Copying terminator instruction")
                                        # Pass the block mapping directly
                                        logger.debug("Block map contents:")
                                        for k, v in block_map.items():
                                            logger.debug(f"  Key type: {type(k)}, Value type: {type(v)}")
                                            logger.debug(f"  Key: {repr(k)}")
                                            logger.debug(f"  Value: {repr(v)}")
                                        self._copy_terminator(instr, block_map, self.context.builder)
                                        logger.debug("Terminator instruction copied successfully")
                                    else:
                                        logger.debug("Copying regular instruction")
                                        self._copy_instruction(instr, self.context.builder)
                                        logger.debug("Regular instruction copied successfully")
                                except Exception as e:
                                    logger.error(f"Failed to copy instruction: {repr(instr)}")
                                    logger.error(f"Error details: {e}")
                                    logger.error(f"Instruction type: {type(instr)}")
                                    if hasattr(instr, 'operands'):
                                        logger.error(f"Operands: {[repr(op) for op in instr.operands]}")
                                        for i, op in enumerate(instr.operands):
                                            logger.error(f"Operand {i} type: {type(op)}")
                                            logger.error(f"Operand {i} repr: {repr(op)}")
                                            if hasattr(op, 'name'):
                                                logger.error(f"Operand {i} name: {op.name}")
                                    raise
                            
                            logger.debug(f"Finished copying instructions for block in {func.name}")
                        
                        logger.debug(f"Finished copying function {func.name}")
                    except Exception as e:
                        logger.error(f"Failed to copy function {func.name}: {e}")
                        logger.error(f"Function type: {type(func)}")
                        logger.error(f"Function repr: {repr(func)}")
                        raise
            
            # Copy global variables
            logger.debug("Starting global variable copy")
            for global_var in globals:
                logger.debug(f"Processing global variable: {repr(global_var)}")
                logger.debug(f"Global variable type: {type(global_var)}")
                try:
                    new_global = ir.GlobalVariable(
                        new_module,
                        global_var.type,
                        global_var.name,
                        addrspace=getattr(global_var, 'addrspace', 0)
                    )
                    new_global.initializer = global_var.initializer
                    # Copy other attributes if they exist
                    for attr in ['linkage', 'storage_class', 'unnamed_addr', 'align']:
                        if hasattr(global_var, attr):
                            setattr(new_global, attr, getattr(global_var, attr))
                    logger.debug(f"Successfully copied global variable {global_var.name}")
                except Exception as e:
                    logger.error(f"Failed to copy global variable {repr(global_var)}: {e}")
                    logger.error(f"Global variable type: {type(global_var)}")
                    raise

            self.module = new_module
            logger.debug("IR generation completed successfully")
            return self.module
        except Exception as e:
            logger.error(f"Error during IR generation: {e}")
            logger.error("Stack trace:", exc_info=True)
            raise

    def _generate_main_function(self):
        """Generate a main function that calls other functions"""
        if self._function_exists("main"):
            return

        # Create main function
        logger.debug("Creating main function type")
        main_type = ir.FunctionType(ir.IntType(32), [])
        logger.debug("Creating main function object")
        main_func = ir.Function(self.module, main_type, "main")
        logger.debug(f"Main function created: {repr(main_func)}")
        
        logger.debug("Creating main function entry block")
        main_block = main_func.append_basic_block("entry")
        logger.debug(f"Main block created: {repr(main_block)}")
        
        # Save current builder state
        old_builder = self.context.builder
        old_function = self.context.current_function
        
        # Set up new function context
        logger.debug("Setting up new builder for main function")
        self.context.builder = ir.IRBuilder(main_block)
        self.context.current_function = main_func
        
        # Add basic initialization code
        # For now, just return 0
        logger.debug("Adding return instruction to main")
        ret_val = ir.Constant(ir.IntType(32), 0)
        logger.debug(f"Created return value: {repr(ret_val)}")
        self.context.builder.ret(ret_val)
        
        # Restore builder state
        logger.debug("Restoring builder state")
        self.context.builder = old_builder
        self.context.current_function = old_function
        self.has_main = True

    def _generate_function(self, symbol: Symbol):
        """Generate IR for a function definition"""
        logger.debug(f"Generating function {symbol.name}")
        
        # Skip if function already exists
        if any(f.name == symbol.name for f in self.module.functions):
            logger.debug(f"Function {symbol.name} already exists, skipping")
            return

        func = self._create_function(symbol.name, symbol.type)
        logger.debug(f"Created function {symbol.name} with type {func.function_type}")
        
        # Save current builder state
        old_builder = self.context.builder
        old_function = self.context.current_function
        
        # Set up new function context
        entry_block = func.append_basic_block("entry")
        self.context.builder = ir.IRBuilder(entry_block)
        self.context.current_function = func
        logger.debug(f"Set up function context for {symbol.name}")
        
        # Add parameters to symbol table
        self.context.enter_scope()  # Create new scope for function parameters
        for param, arg in zip(func.args, symbol.type.param_types):
            # Use a simple name for parameters to avoid any string issues
            param.name = f"param_{len(self.context.symbol_table)}"
            self.context.add_symbol(param.name, param)
            logger.debug(f"Added parameter {param.name} to symbol table")
        
        # Generate function body
        if hasattr(symbol, 'body'):
            if symbol.body is None:
                logger.debug(f"Function {symbol.name} has a 'body' attribute but it is None.")
            else:
                logger.debug(f"Generating body for function {symbol.name}")
                logger.debug(f"Body type: {type(symbol.body)}")
                logger.debug(f"Body data: {symbol.body.data}")
                logger.debug(f"Body children: {[type(c) for c in symbol.body.children]}")
                
                # The body should be a compound_statement
                if symbol.body.data == 'compound_statement':
                    logger.debug("Processing compound statement")
                    for i, child in enumerate(symbol.body.children):
                        logger.debug(f"Processing statement {i}: {child.data}")
                        if isinstance(child, Tree):
                            logger.debug(f"Statement {i} children: {[type(c) for c in child.children]}")
                        self._generate_statement(child)
                else:
                    logger.error(f"Expected compound_statement, got {symbol.body.data}")
                    raise ValueError(f"Invalid function body type: {symbol.body.data}")
        else:
            logger.debug(f"Function {symbol.name} does not have a 'body' attribute.")
            # If no body is provided, add a default return
            if symbol.type.return_type.kind != TypeKind.VOID:
                logger.debug(f"Adding default return 0 for {symbol.name}")
                self.context.builder.ret(ir.Constant(self._get_llvm_type(symbol.type.return_type), 0))
            else:
                logger.debug(f"Adding default void return for {symbol.name}")
                self.context.builder.ret_void()
        
        # Restore builder state
        self.context.exit_scope()
        self.context.builder = old_builder
        self.context.current_function = old_function
        logger.debug(f"Finished generating function {symbol.name}")

    def _generate_global_variable(self, symbol: Symbol):
        """Generate IR for a global variable"""
        # Skip if variable already exists
        if self.module.get_global(symbol.name):
            return

        var_type = self._get_llvm_type(symbol.type)
        if symbol.is_constant:
            # For constants, we'll need to handle initialization
            initializer = ir.Constant(var_type, 0)  # Default to 0
            global_var = ir.GlobalVariable(
                self.module, var_type, symbol.name,
                addrspace=0, constant=True
            )
            global_var.initializer = initializer
        else:
            # For variables, create uninitialized global
            global_var = ir.GlobalVariable(
                self.module, var_type, symbol.name,
                addrspace=0
            )
            global_var.initializer = ir.Constant(var_type, 0)
        self.context.add_symbol(symbol.name, global_var)

    def _generate_string_constant(self, string: str) -> ir.GlobalVariable:
        """Generate a global string constant"""
        # Create a unique name for the string constant
        name = f".str.{len(self.module.globals)}"
        # Create a null-terminated string
        string_bytes = (string + '\0').encode('utf-8')
        # Create a global constant array
        string_type = ir.ArrayType(ir.IntType(8), len(string_bytes))
        string_constant = ir.Constant(string_type, bytearray(string_bytes))
        # Create the global variable
        string_global = ir.GlobalVariable(self.module, string_type, name)
        string_global.initializer = string_constant
        string_global.global_constant = True
        string_global.linkage = 'private'
        logger.debug(f"Created string constant {name} with value: {string}")
        return string_global

    def _generate_expression(self, node: Any) -> ir.Value:
        """Generate IR for an expression"""
        logger.debug(f"Generating expression: {repr(node)}")
        if isinstance(node, Token):
            if node.type == 'NUMBER':
                logger.debug(f"Generating number constant: {node.value}")
                return ir.Constant(ir.IntType(32), int(node.value))
            elif node.type == 'STRING':
                logger.debug(f"Generating string constant: {node.value}")
                # Remove quotes from the string literal
                string_value = node.value.strip('"')
                # Create a unique name for the string constant
                name = f".str.{len(self.module.globals)}"
                # Create a null-terminated string
                string_bytes = (string_value + '\0').encode('utf-8')
                # Create a global constant array
                string_type = ir.ArrayType(ir.IntType(8), len(string_bytes))
                string_constant = ir.Constant(string_type, bytearray(string_bytes))
                # Create the global variable
                string_global = ir.GlobalVariable(self.module, string_type, name)
                string_global.initializer = string_constant
                string_global.global_constant = True
                string_global.linkage = 'private'
                # Get a pointer to the first character
                zero = ir.Constant(ir.IntType(32), 0)
                return self.context.builder.gep(string_global, [zero, zero], name=f"{name}_ptr")
            elif node.type == 'IDENTIFIER':
                logger.debug(f"Generating identifier: {node.value}")
                var = self.context.lookup(node.value)
                if not var:
                    raise ValueError(f"Undeclared variable: {node.value}")
                # Load the value from the pointer
                logger.debug(f"Loading value from {node.value}: {repr(var)}")
                return self.context.builder.load(var)
        elif isinstance(node, Tree):
            if node.data == 'expr':
                if len(node.children) == 1:
                    return self._generate_expression(node.children[0])
                # Binary operation
                left = self._generate_expression(node.children[0])
                right = self._generate_expression(node.children[2])
                op = node.children[1].type
                logger.debug(f"Generating binary operation: {op}")
                
                if op == 'PLUS':
                    return self.context.builder.add(left, right)
                elif op == 'MINUS':
                    return self.context.builder.sub(left, right)
                elif op == 'STAR':
                    return self.context.builder.mul(left, right)
                elif op == 'SLASH':
                    return self.context.builder.sdiv(left, right)
            elif node.data == 'term':
                if len(node.children) == 1:
                    return self._generate_expression(node.children[0])
                # Binary operation
                left = self._generate_expression(node.children[0])
                right = self._generate_expression(node.children[2])
                op = node.children[1].type
                logger.debug(f"Generating term operation: {op}")
                
                if op == 'STAR':
                    return self.context.builder.mul(left, right)
                elif op == 'SLASH':
                    return self.context.builder.sdiv(left, right)
            elif node.data == 'factor':
                return self._generate_expression(node.children[0])
            elif node.data == 'argument':
                # Handle function arguments
                if node.children:
                    return self._generate_expression(node.children[0])
            elif node.data == 'argument_list':
                # Handle argument lists
                args = []
                for child in node.children:
                    if child.data == 'argument':
                        arg = self._generate_expression(child)
                        if arg is not None:
                            args.append(arg)
                return args
            elif node.data == 'assignment_expression':
                logger.debug("Generating assignment expression")
                var_name = self.get_identifier_from_node(node.children[0])
                var = self.context.lookup(var_name)
                if not var:
                    raise ValueError(f"Undeclared variable: {var_name}")
                # Generate the value to be assigned
                value = self._generate_expression(node.children[1])
                # Store the value into the pointer
                logger.debug(f"Storing value {repr(value)} into {var_name} at {repr(var)}")
                self.context.builder.store(value, var)
                return value
            elif node.data == 'function_call':
                logger.debug("Generating function call")
                func_name = self.get_identifier_from_node(node.children[0])
                func = self.module.get_global(func_name)
                if not func:
                    raise ValueError(f"Undeclared function: {func_name}")
                
                # Generate arguments
                args = []
                if len(node.children) > 1 and isinstance(node.children[1], Tree):
                    if node.children[1].data == 'argument_list':
                        args = self._generate_expression(node.children[1])
                    else:
                        for arg in node.children[1].children:
                            if arg.data == 'argument':
                                arg_value = self._generate_expression(arg)
                                if arg_value is not None:
                                    args.append(arg_value)
                
                logger.debug(f"Calling function {func_name} with args: {args}")
                if args:
                    return self.context.builder.call(func, args)
                else:
                    return self.context.builder.call(func, [])
        return None

    def get_identifier_from_node(self, node: Any) -> str:
        """Extract identifier from a node"""
        if isinstance(node, Token):
            return node.value
        elif isinstance(node, Tree):
            if node.data == 'identifier':
                return node.children[0].value
            elif len(node.children) > 0:
                return self.get_identifier_from_node(node.children[0])
        raise ValueError(f"Could not extract identifier from node: {node}")

    def _generate_statement(self, node: Tree) -> None:
        """Generate IR for a statement"""
        logger.debug(f"Generating statement: {node.data}")
        if node.data == 'statement':
            # A statement node wraps the actual statement, so visit its child
            if node.children:
                self._generate_statement(node.children[0])
        elif node.data == 'declaration':
            # Handle variable declaration
            type_node = node.children[0]
            if isinstance(type_node, Tree) and type_node.data == 'type_specifier':
                # Get the type from the semantic analyzer's symbol table
                type_info = self.semantic.get_type_from_node(type_node)
            else:
                type_info = self.get_type_from_node(type_node)
            
            identifier = node.children[1]
            if isinstance(identifier, Token):
                var_name = identifier.value
            else:
                var_name = self.get_identifier_from_node(identifier)
            
            # Look up the symbol in the semantic analyzer's symbol table
            symbol = self.semantic.symbol_table.lookup(var_name)
            if symbol:
                type_info = symbol.type
                logger.debug(f"Found symbol in semantic table: {symbol.name} of type {symbol.type}")
            
            logger.debug(f"Declaring variable: {var_name} of type {type_info}")
            
            # Get the base type for the variable (not the pointer type)
            # For example, if type_info is int*, we want int
            if type_info.kind == TypeKind.POINTER:
                base_type = type_info.base_type
            else:
                base_type = type_info
            
            # Get the LLVM type for the base type
            llvm_type = self._get_llvm_type(base_type)
            logger.debug(f"Variable base type for alloca: {llvm_type}")
            
            # Create alloca instruction for the variable
            # This will create a pointer to the base type (e.g., i32* for i32)
            var = self.context.builder.alloca(llvm_type)
            logger.debug(f"Created alloca for {var_name}: {repr(var)}")
            
            # Store the alloca'd pointer in the symbol table
            self.context.add_symbol(var_name, var)
            
            # Handle initialization if present (before the semicolon)
            if len(node.children) > 2 and not isinstance(node.children[2], Token):
                init_value = self._generate_expression(node.children[2])
                if init_value is not None:
                    logger.debug(f"Initializing {var_name} with value: {repr(init_value)}")
                    self.context.builder.store(init_value, var)
                else:
                    # Initialize with default value (0)
                    default_value = ir.Constant(llvm_type, 0)
                    logger.debug(f"Initializing {var_name} with default value 0")
                    self.context.builder.store(default_value, var)
            else:
                # No initialization, store default value (0)
                default_value = ir.Constant(llvm_type, 0)
                logger.debug(f"Initializing {var_name} with default value 0")
                self.context.builder.store(default_value, var)
        
        elif node.data == 'compound_statement':
            # Handle block of statements
            self.context.enter_scope()
            for child in node.children:
                self._generate_statement(child)
            self.context.exit_scope()
        
        elif node.data == 'expression_statement':
            # Handle expression statement
            if node.children:
                self._generate_expression(node.children[0])
        
        elif node.data == 'return_statement':
            # Handle return statement
            if node.children:
                ret_val = self._generate_expression(node.children[0])
                if ret_val is None:
                    # If no return value, use 0 for main function
                    if self.context.current_function.name == "main":
                        ret_val = ir.Constant(ir.IntType(32), 0)
                    else:
                        self.context.builder.ret_void()
                        return
                self.context.builder.ret(ret_val)
            else:
                # For main function, return 0 if no return value specified
                if self.context.current_function.name == "main":
                    self.context.builder.ret(ir.Constant(ir.IntType(32), 0))
                else:
                    self.context.builder.ret_void()
        
        elif node.data == 'assignment_expression':
            # Handle assignment
            var_name = self.get_identifier_from_node(node.children[0])
            var = self.context.lookup(var_name)
            if not var:
                raise ValueError(f"Undeclared variable: {var_name}")
            value = self._generate_expression(node.children[1])
            if value is not None:
                logger.debug(f"Assigning value {repr(value)} to {var_name}")
                self.context.builder.store(value, var)
        
        elif node.data == 'function_call':
            # Handle function call
            func_name = self.get_identifier_from_node(node.children[0])
            func = self.module.get_global(func_name)
            if not func:
                raise ValueError(f"Undeclared function: {func_name}")
            
            # Generate arguments
            args = []
            if len(node.children) > 1 and isinstance(node.children[1], Tree):
                if node.children[1].data == 'argument_list':
                    args = self._generate_expression(node.children[1])
                else:
                    for arg in node.children[1].children:
                        if arg.data == 'argument':
                            arg_value = self._generate_expression(arg)
                            if arg_value is not None:
                                args.append(arg_value)
            
            logger.debug(f"Calling function {func_name} with args: {args}")
            if args:
                self.context.builder.call(func, args)
            else:
                self.context.builder.call(func, [])

def generate_ir(semantic_analyzer: SemanticAnalyzer) -> ir.Module:
    """
    Generate LLVM IR from semantic analysis results
    
    Args:
        semantic_analyzer: The semantic analyzer containing the analyzed program
        
    Returns:
        ir.Module: The generated LLVM IR module
    """
    generator = IRGenerator(semantic_analyzer)
    return generator.generate() 

def generate_ir_from_file(c_file: str, visualize: bool = False) -> Optional[ir.Module]:
    """
    Generate LLVM IR from a C source file
    
    Args:
        c_file: Path to the C source file
        visualize: Whether to generate symbol table visualization
        
    Returns:
        Optional[ir.Module]: The generated LLVM IR module, or None if there were errors
    """
    # Read and parse the C file
    code = read_c_file(c_file)
    if code is None:
        print(f"Error: Could not read file {c_file}", file=sys.stderr)
        return None
    
    # Create parser and parse the code
    parser = create_parser()
    tree = parse_c_code(parser, code)
    if tree is None:
        print("Error: Failed to parse C code", file=sys.stderr)
        return None
    
    # Perform semantic analysis
    analyzer = SemanticAnalyzer()
    success = analyzer.analyze(tree)
    
    if visualize:
        analyzer.symbol_table.visualize()
    
    # Print any warnings or errors
    for warning in analyzer.warnings:
        print(f"Warning: {warning}", file=sys.stderr)
    for error in analyzer.errors:
        print(f"Error: {error}", file=sys.stderr)
    
    if not success:
        return None
    
    # Generate IR using the semantic analyzer
    try:
        logger.debug("Generating IR from semantic analyzer")
        logger.debug(f"Symbol table has {len(analyzer.symbol_table.get_scope_symbols(0))} global symbols")
        for symbol in analyzer.symbol_table.get_scope_symbols(0):
            logger.debug(f"Global symbol: {symbol.name} (type: {symbol.type.kind})")
            # detects main function
            if symbol.type.kind == TypeKind.FUNCTION and symbol.name == "main":
                logger.debug(f"Main function found in symbol table with body: {symbol.body is not None}")
                if symbol.body:
                    logger.debug(f"Main function body type: {type(symbol.body)}")
                    logger.debug(f"Main function body data: {symbol.body.data}")
                    logger.debug(f"Main function body children: {[type(c) for c in symbol.body.children]}")
        
        # Create IR generator with the semantic analyzer instance
        generator = IRGenerator(analyzer)
        module = generator.generate()
        return module
    except Exception as e:
        print(f"Error generating IR: {e}", file=sys.stderr)
        logger.error("Error generating IR:", exc_info=True)
        return None

def main():
    """Main function to ge nerate IR from a C file"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Generate LLVM IR from C code')
    parser.add_argument('file', help='C source file to compile')
    parser.add_argument('--output', '-o', help='Output file for LLVM IR (default: input.ll)')
    parser.add_argument('--visualize', '-v', action='store_true',
                       help='Generate symbol table visualization')
    
    args = parser.parse_args()
    
    # Generate IR
    module = generate_ir_from_file(args.file, args.visualize)
    if module is None:
        sys.exit(1)
    
    # Determine output file
    if args.output:
        output_file = args.output
    else:
        output_file = str(Path(args.file).with_suffix('.ll'))
    
    # Write IR to file
    try:
        with open(output_file, 'w') as f:
            f.write(str(module))
        print(f"Generated LLVM IR written to {output_file}")
    except Exception as e:
        print(f"Error writing output file: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main() 